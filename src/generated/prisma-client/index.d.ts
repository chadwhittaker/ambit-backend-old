// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  commentLike: (where?: CommentLikeWhereInput) => Promise<boolean>;
  education: (where?: EducationWhereInput) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  filter: (where?: FilterWhereInput) => Promise<boolean>;
  meeting: (where?: MeetingWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  postLike: (where?: PostLikeWhereInput) => Promise<boolean>;
  skill: (where?: SkillWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  commentLike: (
    where: CommentLikeWhereUniqueInput
  ) => CommentLikeNullablePromise;
  commentLikes: (args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CommentLike>;
  commentLikesConnection: (args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentLikeConnectionPromise;
  education: (where: EducationWhereUniqueInput) => EducationNullablePromise;
  educations: (args?: {
    where?: EducationWhereInput;
    orderBy?: EducationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Education>;
  educationsConnection: (args?: {
    where?: EducationWhereInput;
    orderBy?: EducationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EducationConnectionPromise;
  experience: (where: ExperienceWhereUniqueInput) => ExperienceNullablePromise;
  experiences: (args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Experience>;
  experiencesConnection: (args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExperienceConnectionPromise;
  filter: (where: FilterWhereUniqueInput) => FilterNullablePromise;
  filters: (args?: {
    where?: FilterWhereInput;
    orderBy?: FilterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Filter>;
  filtersConnection: (args?: {
    where?: FilterWhereInput;
    orderBy?: FilterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FilterConnectionPromise;
  meeting: (where: MeetingWhereUniqueInput) => MeetingNullablePromise;
  meetings: (args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Meeting>;
  meetingsConnection: (args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MeetingConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  postLike: (where: PostLikeWhereUniqueInput) => PostLikeNullablePromise;
  postLikes: (args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PostLike>;
  postLikesConnection: (args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostLikeConnectionPromise;
  skill: (where: SkillWhereUniqueInput) => SkillNullablePromise;
  skills: (args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Skill>;
  skillsConnection: (args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SkillConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommentLike: (data: CommentLikeCreateInput) => CommentLikePromise;
  updateCommentLike: (args: {
    data: CommentLikeUpdateInput;
    where: CommentLikeWhereUniqueInput;
  }) => CommentLikePromise;
  upsertCommentLike: (args: {
    where: CommentLikeWhereUniqueInput;
    create: CommentLikeCreateInput;
    update: CommentLikeUpdateInput;
  }) => CommentLikePromise;
  deleteCommentLike: (where: CommentLikeWhereUniqueInput) => CommentLikePromise;
  deleteManyCommentLikes: (
    where?: CommentLikeWhereInput
  ) => BatchPayloadPromise;
  createEducation: (data: EducationCreateInput) => EducationPromise;
  updateEducation: (args: {
    data: EducationUpdateInput;
    where: EducationWhereUniqueInput;
  }) => EducationPromise;
  updateManyEducations: (args: {
    data: EducationUpdateManyMutationInput;
    where?: EducationWhereInput;
  }) => BatchPayloadPromise;
  upsertEducation: (args: {
    where: EducationWhereUniqueInput;
    create: EducationCreateInput;
    update: EducationUpdateInput;
  }) => EducationPromise;
  deleteEducation: (where: EducationWhereUniqueInput) => EducationPromise;
  deleteManyEducations: (where?: EducationWhereInput) => BatchPayloadPromise;
  createExperience: (data: ExperienceCreateInput) => ExperiencePromise;
  updateExperience: (args: {
    data: ExperienceUpdateInput;
    where: ExperienceWhereUniqueInput;
  }) => ExperiencePromise;
  updateManyExperiences: (args: {
    data: ExperienceUpdateManyMutationInput;
    where?: ExperienceWhereInput;
  }) => BatchPayloadPromise;
  upsertExperience: (args: {
    where: ExperienceWhereUniqueInput;
    create: ExperienceCreateInput;
    update: ExperienceUpdateInput;
  }) => ExperiencePromise;
  deleteExperience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayloadPromise;
  createFilter: (data: FilterCreateInput) => FilterPromise;
  updateFilter: (args: {
    data: FilterUpdateInput;
    where: FilterWhereUniqueInput;
  }) => FilterPromise;
  upsertFilter: (args: {
    where: FilterWhereUniqueInput;
    create: FilterCreateInput;
    update: FilterUpdateInput;
  }) => FilterPromise;
  deleteFilter: (where: FilterWhereUniqueInput) => FilterPromise;
  deleteManyFilters: (where?: FilterWhereInput) => BatchPayloadPromise;
  createMeeting: (data: MeetingCreateInput) => MeetingPromise;
  updateMeeting: (args: {
    data: MeetingUpdateInput;
    where: MeetingWhereUniqueInput;
  }) => MeetingPromise;
  updateManyMeetings: (args: {
    data: MeetingUpdateManyMutationInput;
    where?: MeetingWhereInput;
  }) => BatchPayloadPromise;
  upsertMeeting: (args: {
    where: MeetingWhereUniqueInput;
    create: MeetingCreateInput;
    update: MeetingUpdateInput;
  }) => MeetingPromise;
  deleteMeeting: (where: MeetingWhereUniqueInput) => MeetingPromise;
  deleteManyMeetings: (where?: MeetingWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createPostLike: (data: PostLikeCreateInput) => PostLikePromise;
  updatePostLike: (args: {
    data: PostLikeUpdateInput;
    where: PostLikeWhereUniqueInput;
  }) => PostLikePromise;
  upsertPostLike: (args: {
    where: PostLikeWhereUniqueInput;
    create: PostLikeCreateInput;
    update: PostLikeUpdateInput;
  }) => PostLikePromise;
  deletePostLike: (where: PostLikeWhereUniqueInput) => PostLikePromise;
  deleteManyPostLikes: (where?: PostLikeWhereInput) => BatchPayloadPromise;
  createSkill: (data: SkillCreateInput) => SkillPromise;
  updateSkill: (args: {
    data: SkillUpdateInput;
    where: SkillWhereUniqueInput;
  }) => SkillPromise;
  updateManySkills: (args: {
    data: SkillUpdateManyMutationInput;
    where?: SkillWhereInput;
  }) => BatchPayloadPromise;
  upsertSkill: (args: {
    where: SkillWhereUniqueInput;
    create: SkillCreateInput;
    update: SkillUpdateInput;
  }) => SkillPromise;
  deleteSkill: (where: SkillWhereUniqueInput) => SkillPromise;
  deleteManySkills: (where?: SkillWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  commentLike: (
    where?: CommentLikeSubscriptionWhereInput
  ) => CommentLikeSubscriptionPayloadSubscription;
  education: (
    where?: EducationSubscriptionWhereInput
  ) => EducationSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  filter: (
    where?: FilterSubscriptionWhereInput
  ) => FilterSubscriptionPayloadSubscription;
  meeting: (
    where?: MeetingSubscriptionWhereInput
  ) => MeetingSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  postLike: (
    where?: PostLikeSubscriptionWhereInput
  ) => PostLikeSubscriptionPayloadSubscription;
  skill: (
    where?: SkillSubscriptionWhereInput
  ) => SkillSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "profilePic_ASC"
  | "profilePic_DESC"
  | "bannerPic_ASC"
  | "bannerPic_DESC"
  | "location_ASC"
  | "location_DESC"
  | "locationLat_ASC"
  | "locationLat_DESC"
  | "locationLon_ASC"
  | "locationLon_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "profession_ASC"
  | "profession_DESC"
  | "industry_ASC"
  | "industry_DESC"
  | "website_ASC"
  | "website_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "intro_ASC"
  | "intro_DESC"
  | "rank_ASC"
  | "rank_DESC";

export type SkillOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "skill_ASC"
  | "skill_DESC"
  | "isExpert_ASC"
  | "isExpert_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "isUpdate_ASC"
  | "isUpdate_DESC"
  | "content_ASC"
  | "content_DESC"
  | "image_ASC"
  | "image_DESC";

export type CommentLikeOrderByInput = "id_ASC" | "id_DESC";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "subText_ASC"
  | "subText_DESC"
  | "startDateMonth_ASC"
  | "startDateMonth_DESC"
  | "startDateYear_ASC"
  | "startDateYear_DESC"
  | "endDateMonth_ASC"
  | "endDateMonth_DESC"
  | "endDateYear_ASC"
  | "endDateYear_DESC"
  | "location_ASC"
  | "location_DESC"
  | "currentRole_ASC"
  | "currentRole_DESC";

export type EducationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "subText_ASC"
  | "subText_DESC"
  | "startDateMonth_ASC"
  | "startDateMonth_DESC"
  | "startDateYear_ASC"
  | "startDateYear_DESC"
  | "endDateMonth_ASC"
  | "endDateMonth_DESC"
  | "endDateYear_ASC"
  | "endDateYear_DESC"
  | "location_ASC"
  | "location_DESC"
  | "currentRole_ASC"
  | "currentRole_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "lastUpdated_ASC"
  | "lastUpdated_DESC"
  | "isGoal_ASC"
  | "isGoal_DESC"
  | "goal_ASC"
  | "goal_DESC"
  | "location_ASC"
  | "location_DESC"
  | "locationLat_ASC"
  | "locationLat_DESC"
  | "locationLon_ASC"
  | "locationLon_DESC"
  | "content_ASC"
  | "content_DESC"
  | "video_ASC"
  | "video_DESC"
  | "pitch_ASC"
  | "pitch_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC";

export type PostLikeOrderByInput = "id_ASC" | "id_DESC";

export type Role = "ADMIN" | "PRO" | "USER" | "BUSINESS" | "SUSPENDED";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type MeetingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "place_ASC"
  | "place_DESC";

export type FilterOrderByInput = "id_ASC" | "id_DESC";

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentUpdateOneWithoutCommentsInput {
  create?: Maybe<CommentCreateWithoutCommentsInput>;
  update?: Maybe<CommentUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<CommentUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface PostLikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<PostWhereInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
  OR?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
  NOT?: Maybe<PostLikeWhereInput[] | PostLikeWhereInput>;
}

export interface CommentUpdateWithoutCommentsDataInput {
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneInput>;
  parentPost?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  parentComment?: Maybe<CommentUpdateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeUpdateManyWithoutParentInput>;
}

export interface CommentLikeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<CommentWhereInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
  OR?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
  NOT?: Maybe<CommentLikeWhereInput[] | CommentLikeWhereInput>;
}

export interface PostUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  update?: Maybe<PostUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PostUpsertWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface FilterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<FilterWhereInput[] | FilterWhereInput>;
  OR?: Maybe<FilterWhereInput[] | FilterWhereInput>;
  NOT?: Maybe<FilterWhereInput[] | FilterWhereInput>;
}

export interface SkillUpdateManyDataInput {
  skill?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
}

export interface UserUpsertWithoutExperienceInput {
  update: UserUpdateWithoutExperienceDataInput;
  create: UserCreateWithoutExperienceInput;
}

export interface UserUpdateinterestsInput {
  set?: Maybe<String[] | String>;
}

export interface PostUpdateWithoutCommentsDataInput {
  lastUpdated?: Maybe<DateTimeInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeUpdateManyWithoutParentInput>;
}

export interface ExperienceUpdateManyWithoutOwnerInput {
  create?: Maybe<
    ExperienceCreateWithoutOwnerInput[] | ExperienceCreateWithoutOwnerInput
  >;
  delete?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  connect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  set?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  disconnect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
  update?: Maybe<
    | ExperienceUpdateWithWhereUniqueWithoutOwnerInput[]
    | ExperienceUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | ExperienceUpsertWithWhereUniqueWithoutOwnerInput[]
    | ExperienceUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  updateMany?: Maybe<
    | ExperienceUpdateManyWithWhereNestedInput[]
    | ExperienceUpdateManyWithWhereNestedInput
  >;
}

export interface SkillSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SkillWhereInput>;
  AND?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
  OR?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
  NOT?: Maybe<SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput>;
}

export interface ExperienceUpdateWithWhereUniqueWithoutOwnerInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateWithoutOwnerDataInput;
}

export interface ExperienceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<UserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  subText?: Maybe<String>;
  subText_not?: Maybe<String>;
  subText_in?: Maybe<String[] | String>;
  subText_not_in?: Maybe<String[] | String>;
  subText_lt?: Maybe<String>;
  subText_lte?: Maybe<String>;
  subText_gt?: Maybe<String>;
  subText_gte?: Maybe<String>;
  subText_contains?: Maybe<String>;
  subText_not_contains?: Maybe<String>;
  subText_starts_with?: Maybe<String>;
  subText_not_starts_with?: Maybe<String>;
  subText_ends_with?: Maybe<String>;
  subText_not_ends_with?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateMonth_not?: Maybe<String>;
  startDateMonth_in?: Maybe<String[] | String>;
  startDateMonth_not_in?: Maybe<String[] | String>;
  startDateMonth_lt?: Maybe<String>;
  startDateMonth_lte?: Maybe<String>;
  startDateMonth_gt?: Maybe<String>;
  startDateMonth_gte?: Maybe<String>;
  startDateMonth_contains?: Maybe<String>;
  startDateMonth_not_contains?: Maybe<String>;
  startDateMonth_starts_with?: Maybe<String>;
  startDateMonth_not_starts_with?: Maybe<String>;
  startDateMonth_ends_with?: Maybe<String>;
  startDateMonth_not_ends_with?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  startDateYear_not?: Maybe<Int>;
  startDateYear_in?: Maybe<Int[] | Int>;
  startDateYear_not_in?: Maybe<Int[] | Int>;
  startDateYear_lt?: Maybe<Int>;
  startDateYear_lte?: Maybe<Int>;
  startDateYear_gt?: Maybe<Int>;
  startDateYear_gte?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateMonth_not?: Maybe<String>;
  endDateMonth_in?: Maybe<String[] | String>;
  endDateMonth_not_in?: Maybe<String[] | String>;
  endDateMonth_lt?: Maybe<String>;
  endDateMonth_lte?: Maybe<String>;
  endDateMonth_gt?: Maybe<String>;
  endDateMonth_gte?: Maybe<String>;
  endDateMonth_contains?: Maybe<String>;
  endDateMonth_not_contains?: Maybe<String>;
  endDateMonth_starts_with?: Maybe<String>;
  endDateMonth_not_starts_with?: Maybe<String>;
  endDateMonth_ends_with?: Maybe<String>;
  endDateMonth_not_ends_with?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  endDateYear_not?: Maybe<Int>;
  endDateYear_in?: Maybe<Int[] | Int>;
  endDateYear_not_in?: Maybe<Int[] | Int>;
  endDateYear_lt?: Maybe<Int>;
  endDateYear_lte?: Maybe<Int>;
  endDateYear_gt?: Maybe<Int>;
  endDateYear_gte?: Maybe<Int>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
  currentRole_not?: Maybe<Boolean>;
  AND?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
  OR?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
  NOT?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
}

export interface ExperienceUpdateWithoutOwnerDataInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profilePic?: Maybe<String>;
  profilePic_not?: Maybe<String>;
  profilePic_in?: Maybe<String[] | String>;
  profilePic_not_in?: Maybe<String[] | String>;
  profilePic_lt?: Maybe<String>;
  profilePic_lte?: Maybe<String>;
  profilePic_gt?: Maybe<String>;
  profilePic_gte?: Maybe<String>;
  profilePic_contains?: Maybe<String>;
  profilePic_not_contains?: Maybe<String>;
  profilePic_starts_with?: Maybe<String>;
  profilePic_not_starts_with?: Maybe<String>;
  profilePic_ends_with?: Maybe<String>;
  profilePic_not_ends_with?: Maybe<String>;
  bannerPic?: Maybe<String>;
  bannerPic_not?: Maybe<String>;
  bannerPic_in?: Maybe<String[] | String>;
  bannerPic_not_in?: Maybe<String[] | String>;
  bannerPic_lt?: Maybe<String>;
  bannerPic_lte?: Maybe<String>;
  bannerPic_gt?: Maybe<String>;
  bannerPic_gte?: Maybe<String>;
  bannerPic_contains?: Maybe<String>;
  bannerPic_not_contains?: Maybe<String>;
  bannerPic_starts_with?: Maybe<String>;
  bannerPic_not_starts_with?: Maybe<String>;
  bannerPic_ends_with?: Maybe<String>;
  bannerPic_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLat_not?: Maybe<Float>;
  locationLat_in?: Maybe<Float[] | Float>;
  locationLat_not_in?: Maybe<Float[] | Float>;
  locationLat_lt?: Maybe<Float>;
  locationLat_lte?: Maybe<Float>;
  locationLat_gt?: Maybe<Float>;
  locationLat_gte?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  locationLon_not?: Maybe<Float>;
  locationLon_in?: Maybe<Float[] | Float>;
  locationLon_not_in?: Maybe<Float[] | Float>;
  locationLon_lt?: Maybe<Float>;
  locationLon_lte?: Maybe<Float>;
  locationLon_gt?: Maybe<Float>;
  locationLon_gte?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  profession?: Maybe<String>;
  profession_not?: Maybe<String>;
  profession_in?: Maybe<String[] | String>;
  profession_not_in?: Maybe<String[] | String>;
  profession_lt?: Maybe<String>;
  profession_lte?: Maybe<String>;
  profession_gt?: Maybe<String>;
  profession_gte?: Maybe<String>;
  profession_contains?: Maybe<String>;
  profession_not_contains?: Maybe<String>;
  profession_starts_with?: Maybe<String>;
  profession_not_starts_with?: Maybe<String>;
  profession_ends_with?: Maybe<String>;
  profession_not_ends_with?: Maybe<String>;
  industry?: Maybe<String>;
  industry_not?: Maybe<String>;
  industry_in?: Maybe<String[] | String>;
  industry_not_in?: Maybe<String[] | String>;
  industry_lt?: Maybe<String>;
  industry_lte?: Maybe<String>;
  industry_gt?: Maybe<String>;
  industry_gte?: Maybe<String>;
  industry_contains?: Maybe<String>;
  industry_not_contains?: Maybe<String>;
  industry_starts_with?: Maybe<String>;
  industry_not_starts_with?: Maybe<String>;
  industry_ends_with?: Maybe<String>;
  industry_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  skills_every?: Maybe<SkillWhereInput>;
  skills_some?: Maybe<SkillWhereInput>;
  skills_none?: Maybe<SkillWhereInput>;
  experience_every?: Maybe<ExperienceWhereInput>;
  experience_some?: Maybe<ExperienceWhereInput>;
  experience_none?: Maybe<ExperienceWhereInput>;
  education_every?: Maybe<EducationWhereInput>;
  education_some?: Maybe<EducationWhereInput>;
  education_none?: Maybe<EducationWhereInput>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  connections_every?: Maybe<UserWhereInput>;
  connections_some?: Maybe<UserWhereInput>;
  connections_none?: Maybe<UserWhereInput>;
  following_every?: Maybe<UserWhereInput>;
  following_some?: Maybe<UserWhereInput>;
  following_none?: Maybe<UserWhereInput>;
  followers_every?: Maybe<UserWhereInput>;
  followers_some?: Maybe<UserWhereInput>;
  followers_none?: Maybe<UserWhereInput>;
  intro?: Maybe<String>;
  intro_not?: Maybe<String>;
  intro_in?: Maybe<String[] | String>;
  intro_not_in?: Maybe<String[] | String>;
  intro_lt?: Maybe<String>;
  intro_lte?: Maybe<String>;
  intro_gt?: Maybe<String>;
  intro_gte?: Maybe<String>;
  intro_contains?: Maybe<String>;
  intro_not_contains?: Maybe<String>;
  intro_starts_with?: Maybe<String>;
  intro_not_starts_with?: Maybe<String>;
  intro_ends_with?: Maybe<String>;
  intro_not_ends_with?: Maybe<String>;
  meetings_every?: Maybe<MeetingWhereInput>;
  meetings_some?: Maybe<MeetingWhereInput>;
  meetings_none?: Maybe<MeetingWhereInput>;
  savedFilters_every?: Maybe<FilterWhereInput>;
  savedFilters_some?: Maybe<FilterWhereInput>;
  savedFilters_none?: Maybe<FilterWhereInput>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ExperienceUpsertWithWhereUniqueWithoutOwnerInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateWithoutOwnerDataInput;
  create: ExperienceCreateWithoutOwnerInput;
}

export interface SkillWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<UserWhereInput>;
  skill?: Maybe<String>;
  skill_not?: Maybe<String>;
  skill_in?: Maybe<String[] | String>;
  skill_not_in?: Maybe<String[] | String>;
  skill_lt?: Maybe<String>;
  skill_lte?: Maybe<String>;
  skill_gt?: Maybe<String>;
  skill_gte?: Maybe<String>;
  skill_contains?: Maybe<String>;
  skill_not_contains?: Maybe<String>;
  skill_starts_with?: Maybe<String>;
  skill_not_starts_with?: Maybe<String>;
  skill_ends_with?: Maybe<String>;
  skill_not_ends_with?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
  isExpert_not?: Maybe<Boolean>;
  AND?: Maybe<SkillWhereInput[] | SkillWhereInput>;
  OR?: Maybe<SkillWhereInput[] | SkillWhereInput>;
  NOT?: Maybe<SkillWhereInput[] | SkillWhereInput>;
}

export interface ExperienceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  subText?: Maybe<String>;
  subText_not?: Maybe<String>;
  subText_in?: Maybe<String[] | String>;
  subText_not_in?: Maybe<String[] | String>;
  subText_lt?: Maybe<String>;
  subText_lte?: Maybe<String>;
  subText_gt?: Maybe<String>;
  subText_gte?: Maybe<String>;
  subText_contains?: Maybe<String>;
  subText_not_contains?: Maybe<String>;
  subText_starts_with?: Maybe<String>;
  subText_not_starts_with?: Maybe<String>;
  subText_ends_with?: Maybe<String>;
  subText_not_ends_with?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateMonth_not?: Maybe<String>;
  startDateMonth_in?: Maybe<String[] | String>;
  startDateMonth_not_in?: Maybe<String[] | String>;
  startDateMonth_lt?: Maybe<String>;
  startDateMonth_lte?: Maybe<String>;
  startDateMonth_gt?: Maybe<String>;
  startDateMonth_gte?: Maybe<String>;
  startDateMonth_contains?: Maybe<String>;
  startDateMonth_not_contains?: Maybe<String>;
  startDateMonth_starts_with?: Maybe<String>;
  startDateMonth_not_starts_with?: Maybe<String>;
  startDateMonth_ends_with?: Maybe<String>;
  startDateMonth_not_ends_with?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  startDateYear_not?: Maybe<Int>;
  startDateYear_in?: Maybe<Int[] | Int>;
  startDateYear_not_in?: Maybe<Int[] | Int>;
  startDateYear_lt?: Maybe<Int>;
  startDateYear_lte?: Maybe<Int>;
  startDateYear_gt?: Maybe<Int>;
  startDateYear_gte?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateMonth_not?: Maybe<String>;
  endDateMonth_in?: Maybe<String[] | String>;
  endDateMonth_not_in?: Maybe<String[] | String>;
  endDateMonth_lt?: Maybe<String>;
  endDateMonth_lte?: Maybe<String>;
  endDateMonth_gt?: Maybe<String>;
  endDateMonth_gte?: Maybe<String>;
  endDateMonth_contains?: Maybe<String>;
  endDateMonth_not_contains?: Maybe<String>;
  endDateMonth_starts_with?: Maybe<String>;
  endDateMonth_not_starts_with?: Maybe<String>;
  endDateMonth_ends_with?: Maybe<String>;
  endDateMonth_not_ends_with?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  endDateYear_not?: Maybe<Int>;
  endDateYear_in?: Maybe<Int[] | Int>;
  endDateYear_not_in?: Maybe<Int[] | Int>;
  endDateYear_lt?: Maybe<Int>;
  endDateYear_lte?: Maybe<Int>;
  endDateYear_gt?: Maybe<Int>;
  endDateYear_gte?: Maybe<Int>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
  currentRole_not?: Maybe<Boolean>;
  AND?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  OR?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
  NOT?: Maybe<ExperienceScalarWhereInput[] | ExperienceScalarWhereInput>;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExperienceWhereInput>;
  AND?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
  OR?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput
  >;
}

export interface ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput;
  data: ExperienceUpdateManyDataInput;
}

export interface CommentLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentLikeWhereInput>;
  AND?: Maybe<
    CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput
  >;
  OR?: Maybe<
    CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CommentLikeSubscriptionWhereInput[] | CommentLikeSubscriptionWhereInput
  >;
}

export interface ExperienceUpdateManyDataInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  interests?: Maybe<UserUpdateinterestsInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface EducationUpdateManyWithoutOwnerInput {
  create?: Maybe<
    EducationCreateWithoutOwnerInput[] | EducationCreateWithoutOwnerInput
  >;
  delete?: Maybe<EducationWhereUniqueInput[] | EducationWhereUniqueInput>;
  connect?: Maybe<EducationWhereUniqueInput[] | EducationWhereUniqueInput>;
  set?: Maybe<EducationWhereUniqueInput[] | EducationWhereUniqueInput>;
  disconnect?: Maybe<EducationWhereUniqueInput[] | EducationWhereUniqueInput>;
  update?: Maybe<
    | EducationUpdateWithWhereUniqueWithoutOwnerInput[]
    | EducationUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | EducationUpsertWithWhereUniqueWithoutOwnerInput[]
    | EducationUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<EducationScalarWhereInput[] | EducationScalarWhereInput>;
  updateMany?: Maybe<
    | EducationUpdateManyWithWhereNestedInput[]
    | EducationUpdateManyWithWhereNestedInput
  >;
}

export interface SkillUpdateManyMutationInput {
  skill?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
}

export interface EducationUpdateWithWhereUniqueWithoutOwnerInput {
  where: EducationWhereUniqueInput;
  data: EducationUpdateWithoutOwnerDataInput;
}

export interface UserUpdateWithoutSkillsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface EducationUpdateWithoutOwnerDataInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface SkillUpdateInput {
  owner?: Maybe<UserUpdateOneRequiredWithoutSkillsInput>;
  skill?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
}

export interface EducationUpsertWithWhereUniqueWithoutOwnerInput {
  where: EducationWhereUniqueInput;
  update: EducationUpdateWithoutOwnerDataInput;
  create: EducationCreateWithoutOwnerInput;
}

export interface UserCreateWithoutSkillsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface EducationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  subText?: Maybe<String>;
  subText_not?: Maybe<String>;
  subText_in?: Maybe<String[] | String>;
  subText_not_in?: Maybe<String[] | String>;
  subText_lt?: Maybe<String>;
  subText_lte?: Maybe<String>;
  subText_gt?: Maybe<String>;
  subText_gte?: Maybe<String>;
  subText_contains?: Maybe<String>;
  subText_not_contains?: Maybe<String>;
  subText_starts_with?: Maybe<String>;
  subText_not_starts_with?: Maybe<String>;
  subText_ends_with?: Maybe<String>;
  subText_not_ends_with?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateMonth_not?: Maybe<String>;
  startDateMonth_in?: Maybe<String[] | String>;
  startDateMonth_not_in?: Maybe<String[] | String>;
  startDateMonth_lt?: Maybe<String>;
  startDateMonth_lte?: Maybe<String>;
  startDateMonth_gt?: Maybe<String>;
  startDateMonth_gte?: Maybe<String>;
  startDateMonth_contains?: Maybe<String>;
  startDateMonth_not_contains?: Maybe<String>;
  startDateMonth_starts_with?: Maybe<String>;
  startDateMonth_not_starts_with?: Maybe<String>;
  startDateMonth_ends_with?: Maybe<String>;
  startDateMonth_not_ends_with?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  startDateYear_not?: Maybe<Int>;
  startDateYear_in?: Maybe<Int[] | Int>;
  startDateYear_not_in?: Maybe<Int[] | Int>;
  startDateYear_lt?: Maybe<Int>;
  startDateYear_lte?: Maybe<Int>;
  startDateYear_gt?: Maybe<Int>;
  startDateYear_gte?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateMonth_not?: Maybe<String>;
  endDateMonth_in?: Maybe<String[] | String>;
  endDateMonth_not_in?: Maybe<String[] | String>;
  endDateMonth_lt?: Maybe<String>;
  endDateMonth_lte?: Maybe<String>;
  endDateMonth_gt?: Maybe<String>;
  endDateMonth_gte?: Maybe<String>;
  endDateMonth_contains?: Maybe<String>;
  endDateMonth_not_contains?: Maybe<String>;
  endDateMonth_starts_with?: Maybe<String>;
  endDateMonth_not_starts_with?: Maybe<String>;
  endDateMonth_ends_with?: Maybe<String>;
  endDateMonth_not_ends_with?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  endDateYear_not?: Maybe<Int>;
  endDateYear_in?: Maybe<Int[] | Int>;
  endDateYear_not_in?: Maybe<Int[] | Int>;
  endDateYear_lt?: Maybe<Int>;
  endDateYear_lte?: Maybe<Int>;
  endDateYear_gt?: Maybe<Int>;
  endDateYear_gte?: Maybe<Int>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
  currentRole_not?: Maybe<Boolean>;
  AND?: Maybe<EducationScalarWhereInput[] | EducationScalarWhereInput>;
  OR?: Maybe<EducationScalarWhereInput[] | EducationScalarWhereInput>;
  NOT?: Maybe<EducationScalarWhereInput[] | EducationScalarWhereInput>;
}

export interface SkillCreateInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneWithoutSkillsInput;
  skill: String;
  isExpert?: Maybe<Boolean>;
}

export interface EducationUpdateManyWithWhereNestedInput {
  where: EducationScalarWhereInput;
  data: EducationUpdateManyDataInput;
}

export interface PostUpsertWithoutLikesInput {
  update: PostUpdateWithoutLikesDataInput;
  create: PostCreateWithoutLikesInput;
}

export interface EducationUpdateManyDataInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface PostUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<PostCreateWithoutLikesInput>;
  update?: Maybe<PostUpdateWithoutLikesDataInput>;
  upsert?: Maybe<PostUpsertWithoutLikesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateManyWithoutOwnerInput {
  create?: Maybe<PostCreateWithoutOwnerInput[] | PostCreateWithoutOwnerInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutOwnerInput[]
    | PostUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutOwnerInput[]
    | PostUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostLikeUpdateInput {
  parent?: Maybe<PostUpdateOneRequiredWithoutLikesInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PostUpdateWithWhereUniqueWithoutOwnerInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutOwnerDataInput;
}

export interface PostCreateOneWithoutLikesInput {
  create?: Maybe<PostCreateWithoutLikesInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateWithoutOwnerDataInput {
  lastUpdated?: Maybe<DateTimeInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeUpdateManyWithoutParentInput>;
  comments?: Maybe<CommentUpdateManyWithoutParentPostInput>;
}

export interface PostLikeCreateInput {
  id?: Maybe<ID_Input>;
  parent: PostCreateOneWithoutLikesInput;
  owner: UserCreateOneInput;
}

export interface PostUpdatetagsInput {
  set?: Maybe<String[] | String>;
}

export interface PostUpdateInput {
  lastUpdated?: Maybe<DateTimeInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeUpdateManyWithoutParentInput>;
  comments?: Maybe<CommentUpdateManyWithoutParentPostInput>;
}

export interface PostUpdateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  lastUpdated: DateTimeInput;
  owner: UserCreateOneWithoutPostsInput;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags?: Maybe<PostCreatetagsInput>;
  images?: Maybe<PostCreateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeCreateManyWithoutParentInput>;
  comments?: Maybe<CommentCreateManyWithoutParentPostInput>;
}

export interface PostLikeUpdateManyWithoutParentInput {
  create?: Maybe<
    PostLikeCreateWithoutParentInput[] | PostLikeCreateWithoutParentInput
  >;
  delete?: Maybe<PostLikeWhereUniqueInput[] | PostLikeWhereUniqueInput>;
  connect?: Maybe<PostLikeWhereUniqueInput[] | PostLikeWhereUniqueInput>;
  set?: Maybe<PostLikeWhereUniqueInput[] | PostLikeWhereUniqueInput>;
  disconnect?: Maybe<PostLikeWhereUniqueInput[] | PostLikeWhereUniqueInput>;
  update?: Maybe<
    | PostLikeUpdateWithWhereUniqueWithoutParentInput[]
    | PostLikeUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | PostLikeUpsertWithWhereUniqueWithoutParentInput[]
    | PostLikeUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<PostLikeScalarWhereInput[] | PostLikeScalarWhereInput>;
}

export interface UserUpsertWithWhereUniqueWithoutMeetingsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutMeetingsDataInput;
  create: UserCreateWithoutMeetingsInput;
}

export interface PostLikeUpdateWithWhereUniqueWithoutParentInput {
  where: PostLikeWhereUniqueInput;
  data: PostLikeUpdateWithoutParentDataInput;
}

export interface UserUpdateWithoutMeetingsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface PostLikeUpdateWithoutParentDataInput {
  owner?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateManyWithoutMeetingsInput {
  create?: Maybe<
    UserCreateWithoutMeetingsInput[] | UserCreateWithoutMeetingsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutMeetingsInput[]
    | UserUpdateWithWhereUniqueWithoutMeetingsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutMeetingsInput[]
    | UserUpsertWithWhereUniqueWithoutMeetingsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutSavedFiltersInput {
  create?: Maybe<UserCreateWithoutSavedFiltersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface MeetingUpdateInput {
  users?: Maybe<UserUpdateManyWithoutMeetingsInput>;
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserCreateManyWithoutMeetingsInput {
  create?: Maybe<
    UserCreateWithoutMeetingsInput[] | UserCreateWithoutMeetingsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface PostLikeUpsertWithWhereUniqueWithoutParentInput {
  where: PostLikeWhereUniqueInput;
  update: PostLikeUpdateWithoutParentDataInput;
  create: PostLikeCreateWithoutParentInput;
}

export interface MeetingCreateInput {
  id?: Maybe<ID_Input>;
  users?: Maybe<UserCreateManyWithoutMeetingsInput>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  place?: Maybe<String>;
}

export interface PostLikeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<PostLikeScalarWhereInput[] | PostLikeScalarWhereInput>;
  OR?: Maybe<PostLikeScalarWhereInput[] | PostLikeScalarWhereInput>;
  NOT?: Maybe<PostLikeScalarWhereInput[] | PostLikeScalarWhereInput>;
}

export interface UserUpdateWithoutSavedFiltersDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface CommentUpdateManyWithoutParentPostInput {
  create?: Maybe<
    CommentCreateWithoutParentPostInput[] | CommentCreateWithoutParentPostInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutParentPostInput[]
    | CommentUpdateWithWhereUniqueWithoutParentPostInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutParentPostInput[]
    | CommentUpsertWithWhereUniqueWithoutParentPostInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneWithoutSavedFiltersInput {
  create?: Maybe<UserCreateWithoutSavedFiltersInput>;
  update?: Maybe<UserUpdateWithoutSavedFiltersDataInput>;
  upsert?: Maybe<UserUpsertWithoutSavedFiltersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CommentUpdateWithWhereUniqueWithoutParentPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutParentPostDataInput;
}

export interface UserCreateWithoutSavedFiltersInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface CommentUpdateWithoutParentPostDataInput {
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneInput>;
  parentComment?: Maybe<CommentUpdateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeUpdateManyWithoutParentInput>;
  comments?: Maybe<CommentUpdateManyWithoutParentCommentInput>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserCreateOneInput>;
  parentPost: PostCreateOneWithoutCommentsInput;
  parentComment?: Maybe<CommentCreateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeCreateManyWithoutParentInput>;
  comments?: Maybe<CommentCreateManyWithoutParentCommentInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  isUpdate?: Maybe<Boolean>;
  isUpdate_not?: Maybe<Boolean>;
  owner?: Maybe<UserWhereInput>;
  parentPost?: Maybe<PostWhereInput>;
  parentComment?: Maybe<CommentWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  likes_every?: Maybe<CommentLikeWhereInput>;
  likes_some?: Maybe<CommentLikeWhereInput>;
  likes_none?: Maybe<CommentLikeWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface MeetingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
  place_not?: Maybe<String>;
  place_in?: Maybe<String[] | String>;
  place_not_in?: Maybe<String[] | String>;
  place_lt?: Maybe<String>;
  place_lte?: Maybe<String>;
  place_gt?: Maybe<String>;
  place_gte?: Maybe<String>;
  place_contains?: Maybe<String>;
  place_not_contains?: Maybe<String>;
  place_starts_with?: Maybe<String>;
  place_not_starts_with?: Maybe<String>;
  place_ends_with?: Maybe<String>;
  place_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
  OR?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
  NOT?: Maybe<MeetingWhereInput[] | MeetingWhereInput>;
}

export interface SkillCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  skill: String;
  isExpert?: Maybe<Boolean>;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  lastUpdated?: Maybe<DateTimeInput>;
  lastUpdated_not?: Maybe<DateTimeInput>;
  lastUpdated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastUpdated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastUpdated_lt?: Maybe<DateTimeInput>;
  lastUpdated_lte?: Maybe<DateTimeInput>;
  lastUpdated_gt?: Maybe<DateTimeInput>;
  lastUpdated_gte?: Maybe<DateTimeInput>;
  owner?: Maybe<UserWhereInput>;
  isGoal?: Maybe<Boolean>;
  isGoal_not?: Maybe<Boolean>;
  goal?: Maybe<String>;
  goal_not?: Maybe<String>;
  goal_in?: Maybe<String[] | String>;
  goal_not_in?: Maybe<String[] | String>;
  goal_lt?: Maybe<String>;
  goal_lte?: Maybe<String>;
  goal_gt?: Maybe<String>;
  goal_gte?: Maybe<String>;
  goal_contains?: Maybe<String>;
  goal_not_contains?: Maybe<String>;
  goal_starts_with?: Maybe<String>;
  goal_not_starts_with?: Maybe<String>;
  goal_ends_with?: Maybe<String>;
  goal_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLat_not?: Maybe<Float>;
  locationLat_in?: Maybe<Float[] | Float>;
  locationLat_not_in?: Maybe<Float[] | Float>;
  locationLat_lt?: Maybe<Float>;
  locationLat_lte?: Maybe<Float>;
  locationLat_gt?: Maybe<Float>;
  locationLat_gte?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  locationLon_not?: Maybe<Float>;
  locationLon_in?: Maybe<Float[] | Float>;
  locationLon_not_in?: Maybe<Float[] | Float>;
  locationLon_lt?: Maybe<Float>;
  locationLon_lte?: Maybe<Float>;
  locationLon_gt?: Maybe<Float>;
  locationLon_gte?: Maybe<Float>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  pitch?: Maybe<String>;
  pitch_not?: Maybe<String>;
  pitch_in?: Maybe<String[] | String>;
  pitch_not_in?: Maybe<String[] | String>;
  pitch_lt?: Maybe<String>;
  pitch_lte?: Maybe<String>;
  pitch_gt?: Maybe<String>;
  pitch_gte?: Maybe<String>;
  pitch_contains?: Maybe<String>;
  pitch_not_contains?: Maybe<String>;
  pitch_starts_with?: Maybe<String>;
  pitch_not_starts_with?: Maybe<String>;
  pitch_ends_with?: Maybe<String>;
  pitch_not_ends_with?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  likes_every?: Maybe<PostLikeWhereInput>;
  likes_some?: Maybe<PostLikeWhereInput>;
  likes_none?: Maybe<PostLikeWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface ExperienceCreateManyWithoutOwnerInput {
  create?: Maybe<
    ExperienceCreateWithoutOwnerInput[] | ExperienceCreateWithoutOwnerInput
  >;
  connect?: Maybe<ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput>;
}

export interface EducationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<UserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  subText?: Maybe<String>;
  subText_not?: Maybe<String>;
  subText_in?: Maybe<String[] | String>;
  subText_not_in?: Maybe<String[] | String>;
  subText_lt?: Maybe<String>;
  subText_lte?: Maybe<String>;
  subText_gt?: Maybe<String>;
  subText_gte?: Maybe<String>;
  subText_contains?: Maybe<String>;
  subText_not_contains?: Maybe<String>;
  subText_starts_with?: Maybe<String>;
  subText_not_starts_with?: Maybe<String>;
  subText_ends_with?: Maybe<String>;
  subText_not_ends_with?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateMonth_not?: Maybe<String>;
  startDateMonth_in?: Maybe<String[] | String>;
  startDateMonth_not_in?: Maybe<String[] | String>;
  startDateMonth_lt?: Maybe<String>;
  startDateMonth_lte?: Maybe<String>;
  startDateMonth_gt?: Maybe<String>;
  startDateMonth_gte?: Maybe<String>;
  startDateMonth_contains?: Maybe<String>;
  startDateMonth_not_contains?: Maybe<String>;
  startDateMonth_starts_with?: Maybe<String>;
  startDateMonth_not_starts_with?: Maybe<String>;
  startDateMonth_ends_with?: Maybe<String>;
  startDateMonth_not_ends_with?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  startDateYear_not?: Maybe<Int>;
  startDateYear_in?: Maybe<Int[] | Int>;
  startDateYear_not_in?: Maybe<Int[] | Int>;
  startDateYear_lt?: Maybe<Int>;
  startDateYear_lte?: Maybe<Int>;
  startDateYear_gt?: Maybe<Int>;
  startDateYear_gte?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateMonth_not?: Maybe<String>;
  endDateMonth_in?: Maybe<String[] | String>;
  endDateMonth_not_in?: Maybe<String[] | String>;
  endDateMonth_lt?: Maybe<String>;
  endDateMonth_lte?: Maybe<String>;
  endDateMonth_gt?: Maybe<String>;
  endDateMonth_gte?: Maybe<String>;
  endDateMonth_contains?: Maybe<String>;
  endDateMonth_not_contains?: Maybe<String>;
  endDateMonth_starts_with?: Maybe<String>;
  endDateMonth_not_starts_with?: Maybe<String>;
  endDateMonth_ends_with?: Maybe<String>;
  endDateMonth_not_ends_with?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  endDateYear_not?: Maybe<Int>;
  endDateYear_in?: Maybe<Int[] | Int>;
  endDateYear_not_in?: Maybe<Int[] | Int>;
  endDateYear_lt?: Maybe<Int>;
  endDateYear_lte?: Maybe<Int>;
  endDateYear_gt?: Maybe<Int>;
  endDateYear_gte?: Maybe<Int>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
  currentRole_not?: Maybe<Boolean>;
  AND?: Maybe<EducationWhereInput[] | EducationWhereInput>;
  OR?: Maybe<EducationWhereInput[] | EducationWhereInput>;
  NOT?: Maybe<EducationWhereInput[] | EducationWhereInput>;
}

export interface EducationCreateManyWithoutOwnerInput {
  create?: Maybe<
    EducationCreateWithoutOwnerInput[] | EducationCreateWithoutOwnerInput
  >;
  connect?: Maybe<EducationWhereUniqueInput[] | EducationWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PostCreateManyWithoutOwnerInput {
  create?: Maybe<PostCreateWithoutOwnerInput[] | PostCreateWithoutOwnerInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface UserUpdateWithoutPostsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface PostCreatetagsInput {
  set?: Maybe<String[] | String>;
}

export interface UserUpdateManyWithoutConnectionsInput {
  create?: Maybe<
    UserCreateWithoutConnectionsInput[] | UserCreateWithoutConnectionsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutConnectionsInput[]
    | UserUpdateWithWhereUniqueWithoutConnectionsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutConnectionsInput[]
    | UserUpsertWithWhereUniqueWithoutConnectionsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface PostLikeCreateManyWithoutParentInput {
  create?: Maybe<
    PostLikeCreateWithoutParentInput[] | PostLikeCreateWithoutParentInput
  >;
  connect?: Maybe<PostLikeWhereUniqueInput[] | PostLikeWhereUniqueInput>;
}

export interface UserUpdateWithWhereUniqueWithoutConnectionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutConnectionsDataInput;
}

export interface CommentCreateManyWithoutParentPostInput {
  create?: Maybe<
    CommentCreateWithoutParentPostInput[] | CommentCreateWithoutParentPostInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface UserUpdateWithoutConnectionsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface CommentCreateOneWithoutCommentsInput {
  create?: Maybe<CommentCreateWithoutCommentsInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface UserUpdateManyWithoutFollowingInput {
  create?: Maybe<
    UserCreateWithoutFollowingInput[] | UserCreateWithoutFollowingInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutFollowingInput[]
    | UserUpdateWithWhereUniqueWithoutFollowingInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutFollowingInput[]
    | UserUpsertWithWhereUniqueWithoutFollowingInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface UserUpdateWithWhereUniqueWithoutFollowingInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowingDataInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFollowingDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface UserCreateManyWithoutConnectionsInput {
  create?: Maybe<
    UserCreateWithoutConnectionsInput[] | UserCreateWithoutConnectionsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateManyWithoutFollowersInput {
  create?: Maybe<
    UserCreateWithoutFollowersInput[] | UserCreateWithoutFollowersInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutFollowersInput[]
    | UserUpdateWithWhereUniqueWithoutFollowersInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutFollowersInput[]
    | UserUpsertWithWhereUniqueWithoutFollowersInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateManyWithoutFollowingInput {
  create?: Maybe<
    UserCreateWithoutFollowingInput[] | UserCreateWithoutFollowingInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateWithWhereUniqueWithoutFollowersInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowersDataInput;
}

export interface UserCreateManyWithoutFollowersInput {
  create?: Maybe<
    UserCreateWithoutFollowersInput[] | UserCreateWithoutFollowersInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFollowersDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface UserCreateprojectsInput {
  set?: Maybe<String[] | String>;
}

export interface UserUpdateprojectsInput {
  set?: Maybe<String[] | String>;
}

export interface MeetingCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  startTime: DateTimeInput;
  endTime: DateTimeInput;
  place?: Maybe<String>;
}

export interface MeetingUpdateManyWithoutUsersInput {
  create?: Maybe<
    MeetingCreateWithoutUsersInput[] | MeetingCreateWithoutUsersInput
  >;
  delete?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  connect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  set?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  disconnect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
  update?: Maybe<
    | MeetingUpdateWithWhereUniqueWithoutUsersInput[]
    | MeetingUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | MeetingUpsertWithWhereUniqueWithoutUsersInput[]
    | MeetingUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  updateMany?: Maybe<
    | MeetingUpdateManyWithWhereNestedInput[]
    | MeetingUpdateManyWithWhereNestedInput
  >;
}

export interface FilterCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
}

export interface MeetingUpdateWithWhereUniqueWithoutUsersInput {
  where: MeetingWhereUniqueInput;
  data: MeetingUpdateWithoutUsersDataInput;
}

export interface CommentLikeCreateManyWithoutParentInput {
  create?: Maybe<
    CommentLikeCreateWithoutParentInput[] | CommentLikeCreateWithoutParentInput
  >;
  connect?: Maybe<CommentLikeWhereUniqueInput[] | CommentLikeWhereUniqueInput>;
}

export interface MeetingUpdateWithoutUsersDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
}

export interface CommentCreateManyWithoutParentCommentInput {
  create?: Maybe<
    | CommentCreateWithoutParentCommentInput[]
    | CommentCreateWithoutParentCommentInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface MeetingUpsertWithWhereUniqueWithoutUsersInput {
  where: MeetingWhereUniqueInput;
  update: MeetingUpdateWithoutUsersDataInput;
  create: MeetingCreateWithoutUsersInput;
}

export interface CommentUpdateInput {
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneInput>;
  parentPost?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  parentComment?: Maybe<CommentUpdateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeUpdateManyWithoutParentInput>;
  comments?: Maybe<CommentUpdateManyWithoutParentCommentInput>;
}

export interface MeetingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  endTime_not?: Maybe<DateTimeInput>;
  endTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endTime_lt?: Maybe<DateTimeInput>;
  endTime_lte?: Maybe<DateTimeInput>;
  endTime_gt?: Maybe<DateTimeInput>;
  endTime_gte?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
  place_not?: Maybe<String>;
  place_in?: Maybe<String[] | String>;
  place_not_in?: Maybe<String[] | String>;
  place_lt?: Maybe<String>;
  place_lte?: Maybe<String>;
  place_gt?: Maybe<String>;
  place_gte?: Maybe<String>;
  place_contains?: Maybe<String>;
  place_not_contains?: Maybe<String>;
  place_starts_with?: Maybe<String>;
  place_not_starts_with?: Maybe<String>;
  place_ends_with?: Maybe<String>;
  place_not_ends_with?: Maybe<String>;
  AND?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  OR?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
  NOT?: Maybe<MeetingScalarWhereInput[] | MeetingScalarWhereInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface MeetingUpdateManyWithWhereNestedInput {
  where: MeetingScalarWhereInput;
  data: MeetingUpdateManyDataInput;
}

export interface SkillUpdateWithWhereUniqueWithoutOwnerInput {
  where: SkillWhereUniqueInput;
  data: SkillUpdateWithoutOwnerDataInput;
}

export interface MeetingUpdateManyDataInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
}

export interface SkillUpsertWithWhereUniqueWithoutOwnerInput {
  where: SkillWhereUniqueInput;
  update: SkillUpdateWithoutOwnerDataInput;
  create: SkillCreateWithoutOwnerInput;
}

export interface FilterUpdateManyWithoutOwnerInput {
  create?: Maybe<
    FilterCreateWithoutOwnerInput[] | FilterCreateWithoutOwnerInput
  >;
  delete?: Maybe<FilterWhereUniqueInput[] | FilterWhereUniqueInput>;
  connect?: Maybe<FilterWhereUniqueInput[] | FilterWhereUniqueInput>;
  set?: Maybe<FilterWhereUniqueInput[] | FilterWhereUniqueInput>;
  disconnect?: Maybe<FilterWhereUniqueInput[] | FilterWhereUniqueInput>;
  deleteMany?: Maybe<FilterScalarWhereInput[] | FilterScalarWhereInput>;
}

export interface SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput;
  data: SkillUpdateManyDataInput;
}

export interface FilterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<FilterScalarWhereInput[] | FilterScalarWhereInput>;
  OR?: Maybe<FilterScalarWhereInput[] | FilterScalarWhereInput>;
  NOT?: Maybe<FilterScalarWhereInput[] | FilterScalarWhereInput>;
}

export interface PostLikeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostLikeWhereInput>;
  AND?: Maybe<
    PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput
  >;
  OR?: Maybe<PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput>;
  NOT?: Maybe<
    PostLikeSubscriptionWhereInput[] | PostLikeSubscriptionWhereInput
  >;
}

export interface UserUpdaterolesInput {
  set?: Maybe<Role[] | Role>;
}

export interface MeetingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MeetingWhereInput>;
  AND?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
  OR?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
  NOT?: Maybe<MeetingSubscriptionWhereInput[] | MeetingSubscriptionWhereInput>;
}

export interface UserUpsertWithWhereUniqueWithoutFollowersInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowersDataInput;
  create: UserCreateWithoutFollowersInput;
}

export interface EducationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EducationWhereInput>;
  AND?: Maybe<
    EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput
  >;
  OR?: Maybe<
    EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    EducationSubscriptionWhereInput[] | EducationSubscriptionWhereInput
  >;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profilePic?: Maybe<String>;
  profilePic_not?: Maybe<String>;
  profilePic_in?: Maybe<String[] | String>;
  profilePic_not_in?: Maybe<String[] | String>;
  profilePic_lt?: Maybe<String>;
  profilePic_lte?: Maybe<String>;
  profilePic_gt?: Maybe<String>;
  profilePic_gte?: Maybe<String>;
  profilePic_contains?: Maybe<String>;
  profilePic_not_contains?: Maybe<String>;
  profilePic_starts_with?: Maybe<String>;
  profilePic_not_starts_with?: Maybe<String>;
  profilePic_ends_with?: Maybe<String>;
  profilePic_not_ends_with?: Maybe<String>;
  bannerPic?: Maybe<String>;
  bannerPic_not?: Maybe<String>;
  bannerPic_in?: Maybe<String[] | String>;
  bannerPic_not_in?: Maybe<String[] | String>;
  bannerPic_lt?: Maybe<String>;
  bannerPic_lte?: Maybe<String>;
  bannerPic_gt?: Maybe<String>;
  bannerPic_gte?: Maybe<String>;
  bannerPic_contains?: Maybe<String>;
  bannerPic_not_contains?: Maybe<String>;
  bannerPic_starts_with?: Maybe<String>;
  bannerPic_not_starts_with?: Maybe<String>;
  bannerPic_ends_with?: Maybe<String>;
  bannerPic_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLat_not?: Maybe<Float>;
  locationLat_in?: Maybe<Float[] | Float>;
  locationLat_not_in?: Maybe<Float[] | Float>;
  locationLat_lt?: Maybe<Float>;
  locationLat_lte?: Maybe<Float>;
  locationLat_gt?: Maybe<Float>;
  locationLat_gte?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  locationLon_not?: Maybe<Float>;
  locationLon_in?: Maybe<Float[] | Float>;
  locationLon_not_in?: Maybe<Float[] | Float>;
  locationLon_lt?: Maybe<Float>;
  locationLon_lte?: Maybe<Float>;
  locationLon_gt?: Maybe<Float>;
  locationLon_gte?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  profession?: Maybe<String>;
  profession_not?: Maybe<String>;
  profession_in?: Maybe<String[] | String>;
  profession_not_in?: Maybe<String[] | String>;
  profession_lt?: Maybe<String>;
  profession_lte?: Maybe<String>;
  profession_gt?: Maybe<String>;
  profession_gte?: Maybe<String>;
  profession_contains?: Maybe<String>;
  profession_not_contains?: Maybe<String>;
  profession_starts_with?: Maybe<String>;
  profession_not_starts_with?: Maybe<String>;
  profession_ends_with?: Maybe<String>;
  profession_not_ends_with?: Maybe<String>;
  industry?: Maybe<String>;
  industry_not?: Maybe<String>;
  industry_in?: Maybe<String[] | String>;
  industry_not_in?: Maybe<String[] | String>;
  industry_lt?: Maybe<String>;
  industry_lte?: Maybe<String>;
  industry_gt?: Maybe<String>;
  industry_gte?: Maybe<String>;
  industry_contains?: Maybe<String>;
  industry_not_contains?: Maybe<String>;
  industry_starts_with?: Maybe<String>;
  industry_not_starts_with?: Maybe<String>;
  industry_ends_with?: Maybe<String>;
  industry_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  intro?: Maybe<String>;
  intro_not?: Maybe<String>;
  intro_in?: Maybe<String[] | String>;
  intro_not_in?: Maybe<String[] | String>;
  intro_lt?: Maybe<String>;
  intro_lte?: Maybe<String>;
  intro_gt?: Maybe<String>;
  intro_gte?: Maybe<String>;
  intro_contains?: Maybe<String>;
  intro_not_contains?: Maybe<String>;
  intro_starts_with?: Maybe<String>;
  intro_not_starts_with?: Maybe<String>;
  intro_ends_with?: Maybe<String>;
  intro_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutSkillsInput {
  create?: Maybe<UserCreateWithoutSkillsInput>;
  update?: Maybe<UserUpdateWithoutSkillsDataInput>;
  upsert?: Maybe<UserUpsertWithoutSkillsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  interests?: Maybe<UserUpdateinterestsInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface UserCreateOneWithoutSkillsInput {
  create?: Maybe<UserCreateWithoutSkillsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutFollowingInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowingDataInput;
  create: UserCreateWithoutFollowingInput;
}

export interface PostUpdateWithoutLikesDataInput {
  lastUpdated?: Maybe<DateTimeInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  comments?: Maybe<CommentUpdateManyWithoutParentPostInput>;
}

export interface UserUpsertWithWhereUniqueWithoutConnectionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutConnectionsDataInput;
  create: UserCreateWithoutConnectionsInput;
}

export interface PostCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  lastUpdated: DateTimeInput;
  owner: UserCreateOneWithoutPostsInput;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags?: Maybe<PostCreatetagsInput>;
  images?: Maybe<PostCreateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  comments?: Maybe<CommentCreateManyWithoutParentPostInput>;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface PostUpdateManyMutationInput {
  lastUpdated?: Maybe<DateTimeInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface MeetingUpdateManyMutationInput {
  startTime?: Maybe<DateTimeInput>;
  endTime?: Maybe<DateTimeInput>;
  place?: Maybe<String>;
}

export interface CommentLikeUpdateManyWithoutParentInput {
  create?: Maybe<
    CommentLikeCreateWithoutParentInput[] | CommentLikeCreateWithoutParentInput
  >;
  delete?: Maybe<CommentLikeWhereUniqueInput[] | CommentLikeWhereUniqueInput>;
  connect?: Maybe<CommentLikeWhereUniqueInput[] | CommentLikeWhereUniqueInput>;
  set?: Maybe<CommentLikeWhereUniqueInput[] | CommentLikeWhereUniqueInput>;
  disconnect?: Maybe<
    CommentLikeWhereUniqueInput[] | CommentLikeWhereUniqueInput
  >;
  update?: Maybe<
    | CommentLikeUpdateWithWhereUniqueWithoutParentInput[]
    | CommentLikeUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | CommentLikeUpsertWithWhereUniqueWithoutParentInput[]
    | CommentLikeUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    CommentLikeScalarWhereInput[] | CommentLikeScalarWhereInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutMeetingsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutMeetingsDataInput;
}

export interface CommentLikeUpdateWithWhereUniqueWithoutParentInput {
  where: CommentLikeWhereUniqueInput;
  data: CommentLikeUpdateWithoutParentDataInput;
}

export interface UserCreateWithoutMeetingsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface CommentLikeUpdateWithoutParentDataInput {
  owner?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpsertWithoutSavedFiltersInput {
  update: UserUpdateWithoutSavedFiltersDataInput;
  create: UserCreateWithoutSavedFiltersInput;
}

export interface CommentLikeUpsertWithWhereUniqueWithoutParentInput {
  where: CommentLikeWhereUniqueInput;
  update: CommentLikeUpdateWithoutParentDataInput;
  create: CommentLikeCreateWithoutParentInput;
}

export interface FilterUpdateInput {
  owner?: Maybe<UserUpdateOneWithoutSavedFiltersInput>;
}

export interface CommentLikeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<CommentLikeScalarWhereInput[] | CommentLikeScalarWhereInput>;
  OR?: Maybe<CommentLikeScalarWhereInput[] | CommentLikeScalarWhereInput>;
  NOT?: Maybe<CommentLikeScalarWhereInput[] | CommentLikeScalarWhereInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CommentUpsertWithoutCommentsInput {
  update: CommentUpdateWithoutCommentsDataInput;
  create: CommentCreateWithoutCommentsInput;
}

export interface UserCreateinterestsInput {
  set?: Maybe<String[] | String>;
}

export interface CommentUpdateManyWithoutParentCommentInput {
  create?: Maybe<
    | CommentCreateWithoutParentCommentInput[]
    | CommentCreateWithoutParentCommentInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    | CommentUpdateWithWhereUniqueWithoutParentCommentInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    | CommentUpsertWithWhereUniqueWithoutParentCommentInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface EducationCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface CommentUpdateWithWhereUniqueWithoutParentCommentInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutParentCommentDataInput;
}

export interface PostCreateimagesInput {
  set?: Maybe<String[] | String>;
}

export interface CommentUpdateWithoutParentCommentDataInput {
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneInput>;
  parentPost?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeUpdateManyWithoutParentInput>;
  comments?: Maybe<CommentUpdateManyWithoutParentCommentInput>;
}

export interface CommentCreateWithoutParentPostInput {
  id?: Maybe<ID_Input>;
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserCreateOneInput>;
  parentComment?: Maybe<CommentCreateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeCreateManyWithoutParentInput>;
  comments?: Maybe<CommentCreateManyWithoutParentCommentInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutParentCommentInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutParentCommentDataInput;
  create: CommentCreateWithoutParentCommentInput;
}

export interface PostCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  lastUpdated: DateTimeInput;
  owner: UserCreateOneWithoutPostsInput;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags?: Maybe<PostCreatetagsInput>;
  images?: Maybe<PostCreateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeCreateManyWithoutParentInput>;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  isUpdate?: Maybe<Boolean>;
  isUpdate_not?: Maybe<Boolean>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface UserCreateWithoutConnectionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface UserCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface CommentUpdateManyDataInput {
  isUpdate?: Maybe<Boolean>;
  content?: Maybe<String>;
  image?: Maybe<String>;
}

export interface FilterCreateManyWithoutOwnerInput {
  create?: Maybe<
    FilterCreateWithoutOwnerInput[] | FilterCreateWithoutOwnerInput
  >;
  connect?: Maybe<FilterWhereUniqueInput[] | FilterWhereUniqueInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutParentPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutParentPostDataInput;
  create: CommentCreateWithoutParentPostInput;
}

export interface CommentLikeCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneInput;
}

export interface PostUpsertWithWhereUniqueWithoutOwnerInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutOwnerDataInput;
  create: PostCreateWithoutOwnerInput;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  lastUpdated?: Maybe<DateTimeInput>;
  lastUpdated_not?: Maybe<DateTimeInput>;
  lastUpdated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastUpdated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastUpdated_lt?: Maybe<DateTimeInput>;
  lastUpdated_lte?: Maybe<DateTimeInput>;
  lastUpdated_gt?: Maybe<DateTimeInput>;
  lastUpdated_gte?: Maybe<DateTimeInput>;
  isGoal?: Maybe<Boolean>;
  isGoal_not?: Maybe<Boolean>;
  goal?: Maybe<String>;
  goal_not?: Maybe<String>;
  goal_in?: Maybe<String[] | String>;
  goal_not_in?: Maybe<String[] | String>;
  goal_lt?: Maybe<String>;
  goal_lte?: Maybe<String>;
  goal_gt?: Maybe<String>;
  goal_gte?: Maybe<String>;
  goal_contains?: Maybe<String>;
  goal_not_contains?: Maybe<String>;
  goal_starts_with?: Maybe<String>;
  goal_not_starts_with?: Maybe<String>;
  goal_ends_with?: Maybe<String>;
  goal_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLat_not?: Maybe<Float>;
  locationLat_in?: Maybe<Float[] | Float>;
  locationLat_not_in?: Maybe<Float[] | Float>;
  locationLat_lt?: Maybe<Float>;
  locationLat_lte?: Maybe<Float>;
  locationLat_gt?: Maybe<Float>;
  locationLat_gte?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  locationLon_not?: Maybe<Float>;
  locationLon_in?: Maybe<Float[] | Float>;
  locationLon_not_in?: Maybe<Float[] | Float>;
  locationLon_lt?: Maybe<Float>;
  locationLon_lte?: Maybe<Float>;
  locationLon_gt?: Maybe<Float>;
  locationLon_gte?: Maybe<Float>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  video?: Maybe<String>;
  video_not?: Maybe<String>;
  video_in?: Maybe<String[] | String>;
  video_not_in?: Maybe<String[] | String>;
  video_lt?: Maybe<String>;
  video_lte?: Maybe<String>;
  video_gt?: Maybe<String>;
  video_gte?: Maybe<String>;
  video_contains?: Maybe<String>;
  video_not_contains?: Maybe<String>;
  video_starts_with?: Maybe<String>;
  video_not_starts_with?: Maybe<String>;
  video_ends_with?: Maybe<String>;
  video_not_ends_with?: Maybe<String>;
  pitch?: Maybe<String>;
  pitch_not?: Maybe<String>;
  pitch_in?: Maybe<String[] | String>;
  pitch_not_in?: Maybe<String[] | String>;
  pitch_lt?: Maybe<String>;
  pitch_lte?: Maybe<String>;
  pitch_gt?: Maybe<String>;
  pitch_gte?: Maybe<String>;
  pitch_contains?: Maybe<String>;
  pitch_not_contains?: Maybe<String>;
  pitch_starts_with?: Maybe<String>;
  pitch_not_starts_with?: Maybe<String>;
  pitch_ends_with?: Maybe<String>;
  pitch_not_ends_with?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface SkillUpdateWithoutOwnerDataInput {
  skill?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PostUpdateManyDataInput {
  lastUpdated?: Maybe<DateTimeInput>;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  content?: Maybe<String>;
  tags?: Maybe<PostUpdatetagsInput>;
  images?: Maybe<PostUpdateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
}

export interface FilterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FilterWhereInput>;
  AND?: Maybe<FilterSubscriptionWhereInput[] | FilterSubscriptionWhereInput>;
  OR?: Maybe<FilterSubscriptionWhereInput[] | FilterSubscriptionWhereInput>;
  NOT?: Maybe<FilterSubscriptionWhereInput[] | FilterSubscriptionWhereInput>;
}

export interface CommentUpdateManyMutationInput {
  isUpdate?: Maybe<Boolean>;
  content?: Maybe<String>;
  image?: Maybe<String>;
}

export interface UserUpsertWithoutSkillsInput {
  update: UserUpdateWithoutSkillsDataInput;
  create: UserCreateWithoutSkillsInput;
}

export interface FilterCreateInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<UserCreateOneWithoutSavedFiltersInput>;
}

export type EducationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ExperienceUpdateManyMutationInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export type FilterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentLikeCreateInput {
  id?: Maybe<ID_Input>;
  parent: CommentCreateOneWithoutLikesInput;
  owner: UserCreateOneInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentCreateOneWithoutLikesInput {
  create?: Maybe<CommentCreateWithoutLikesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export type SkillWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CommentCreateWithoutLikesInput {
  id?: Maybe<ID_Input>;
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserCreateOneInput>;
  parentPost: PostCreateOneWithoutCommentsInput;
  parentComment?: Maybe<CommentCreateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  comments?: Maybe<CommentCreateManyWithoutParentCommentInput>;
}

export interface ExperienceCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface CommentLikeUpdateInput {
  parent?: Maybe<CommentUpdateOneRequiredWithoutLikesInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
}

export interface PostLikeCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneInput;
}

export interface CommentUpdateOneRequiredWithoutLikesInput {
  create?: Maybe<CommentCreateWithoutLikesInput>;
  update?: Maybe<CommentUpdateWithoutLikesDataInput>;
  upsert?: Maybe<CommentUpsertWithoutLikesInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface CommentUpdateWithoutLikesDataInput {
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserUpdateOneInput>;
  parentPost?: Maybe<PostUpdateOneRequiredWithoutCommentsInput>;
  parentComment?: Maybe<CommentUpdateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyWithoutParentCommentInput>;
}

export interface MeetingCreateManyWithoutUsersInput {
  create?: Maybe<
    MeetingCreateWithoutUsersInput[] | MeetingCreateWithoutUsersInput
  >;
  connect?: Maybe<MeetingWhereUniqueInput[] | MeetingWhereUniqueInput>;
}

export interface CommentUpsertWithoutLikesInput {
  update: CommentUpdateWithoutLikesDataInput;
  create: CommentCreateWithoutLikesInput;
}

export interface CommentCreateWithoutParentCommentInput {
  id?: Maybe<ID_Input>;
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserCreateOneInput>;
  parentPost: PostCreateOneWithoutCommentsInput;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeCreateManyWithoutParentInput>;
  comments?: Maybe<CommentCreateManyWithoutParentCommentInput>;
}

export interface EducationCreateInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneWithoutEducationInput;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface SkillScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  skill?: Maybe<String>;
  skill_not?: Maybe<String>;
  skill_in?: Maybe<String[] | String>;
  skill_not_in?: Maybe<String[] | String>;
  skill_lt?: Maybe<String>;
  skill_lte?: Maybe<String>;
  skill_gt?: Maybe<String>;
  skill_gte?: Maybe<String>;
  skill_contains?: Maybe<String>;
  skill_not_contains?: Maybe<String>;
  skill_starts_with?: Maybe<String>;
  skill_not_starts_with?: Maybe<String>;
  skill_ends_with?: Maybe<String>;
  skill_not_ends_with?: Maybe<String>;
  isExpert?: Maybe<Boolean>;
  isExpert_not?: Maybe<Boolean>;
  AND?: Maybe<SkillScalarWhereInput[] | SkillScalarWhereInput>;
  OR?: Maybe<SkillScalarWhereInput[] | SkillScalarWhereInput>;
  NOT?: Maybe<SkillScalarWhereInput[] | SkillScalarWhereInput>;
}

export interface UserCreateOneWithoutEducationInput {
  create?: Maybe<UserCreateWithoutEducationInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface UserCreateWithoutEducationInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EducationUpdateInput {
  owner?: Maybe<UserUpdateOneRequiredWithoutEducationInput>;
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export type PostLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutEducationInput {
  create?: Maybe<UserCreateWithoutEducationInput>;
  update?: Maybe<UserUpdateWithoutEducationDataInput>;
  upsert?: Maybe<UserUpsertWithoutEducationInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SkillCreateManyWithoutOwnerInput {
  create?: Maybe<SkillCreateWithoutOwnerInput[] | SkillCreateWithoutOwnerInput>;
  connect?: Maybe<SkillWhereUniqueInput[] | SkillWhereUniqueInput>;
}

export interface UserUpdateWithoutEducationDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  experience?: Maybe<ExperienceUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface CommentCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  isUpdate?: Maybe<Boolean>;
  owner?: Maybe<UserCreateOneInput>;
  parentPost: PostCreateOneWithoutCommentsInput;
  parentComment?: Maybe<CommentCreateOneWithoutCommentsInput>;
  content?: Maybe<String>;
  image?: Maybe<String>;
  likes?: Maybe<CommentLikeCreateManyWithoutParentInput>;
}

export interface UserUpsertWithoutEducationInput {
  update: UserUpdateWithoutEducationDataInput;
  create: UserCreateWithoutEducationInput;
}

export interface UserCreaterolesInput {
  set?: Maybe<Role[] | Role>;
}

export interface EducationUpdateManyMutationInput {
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface ExperienceCreateInput {
  id?: Maybe<ID_Input>;
  owner: UserCreateOneWithoutExperienceInput;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export type MeetingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateOneWithoutExperienceInput {
  create?: Maybe<UserCreateWithoutExperienceInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PostCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  lastUpdated: DateTimeInput;
  isGoal?: Maybe<Boolean>;
  goal?: Maybe<String>;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags?: Maybe<PostCreatetagsInput>;
  images?: Maybe<PostCreateimagesInput>;
  video?: Maybe<String>;
  pitch?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  likes?: Maybe<PostLikeCreateManyWithoutParentInput>;
  comments?: Maybe<CommentCreateManyWithoutParentPostInput>;
}

export interface UserUpdateWithoutExperienceDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillUpdateManyWithoutOwnerInput>;
  interests?: Maybe<UserUpdateinterestsInput>;
  education?: Maybe<EducationUpdateManyWithoutOwnerInput>;
  posts?: Maybe<PostUpdateManyWithoutOwnerInput>;
  connections?: Maybe<UserUpdateManyWithoutConnectionsInput>;
  following?: Maybe<UserUpdateManyWithoutFollowingInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserUpdateprojectsInput>;
  meetings?: Maybe<MeetingUpdateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterUpdateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface UserUpdateOneRequiredWithoutExperienceInput {
  create?: Maybe<UserCreateWithoutExperienceInput>;
  update?: Maybe<UserUpdateWithoutExperienceDataInput>;
  upsert?: Maybe<UserUpsertWithoutExperienceInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ExperienceUpdateInput {
  owner?: Maybe<UserUpdateOneRequiredWithoutExperienceInput>;
  name?: Maybe<String>;
  subText?: Maybe<String>;
  startDateMonth?: Maybe<String>;
  startDateYear?: Maybe<Int>;
  endDateMonth?: Maybe<String>;
  endDateYear?: Maybe<Int>;
  location?: Maybe<String>;
  currentRole?: Maybe<Boolean>;
}

export interface UserCreateWithoutExperienceInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  following?: Maybe<UserCreateManyWithoutFollowingInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface UserCreateWithoutFollowingInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  password: String;
  profilePic?: Maybe<String>;
  bannerPic?: Maybe<String>;
  location?: Maybe<String>;
  locationLat?: Maybe<Float>;
  locationLon?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  profession?: Maybe<String>;
  industry?: Maybe<String>;
  website?: Maybe<String>;
  bio?: Maybe<String>;
  skills?: Maybe<SkillCreateManyWithoutOwnerInput>;
  interests?: Maybe<UserCreateinterestsInput>;
  experience?: Maybe<ExperienceCreateManyWithoutOwnerInput>;
  education?: Maybe<EducationCreateManyWithoutOwnerInput>;
  posts?: Maybe<PostCreateManyWithoutOwnerInput>;
  connections?: Maybe<UserCreateManyWithoutConnectionsInput>;
  followers?: Maybe<UserCreateManyWithoutFollowersInput>;
  intro?: Maybe<String>;
  projects?: Maybe<UserCreateprojectsInput>;
  meetings?: Maybe<MeetingCreateManyWithoutUsersInput>;
  savedFilters?: Maybe<FilterCreateManyWithoutOwnerInput>;
  rank?: Maybe<Int>;
  roles?: Maybe<UserCreaterolesInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export type CommentLikeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SkillUpdateManyWithoutOwnerInput {
  create?: Maybe<SkillCreateWithoutOwnerInput[] | SkillCreateWithoutOwnerInput>;
  delete?: Maybe<SkillWhereUniqueInput[] | SkillWhereUniqueInput>;
  connect?: Maybe<SkillWhereUniqueInput[] | SkillWhereUniqueInput>;
  set?: Maybe<SkillWhereUniqueInput[] | SkillWhereUniqueInput>;
  disconnect?: Maybe<SkillWhereUniqueInput[] | SkillWhereUniqueInput>;
  update?: Maybe<
    | SkillUpdateWithWhereUniqueWithoutOwnerInput[]
    | SkillUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | SkillUpsertWithWhereUniqueWithoutOwnerInput[]
    | SkillUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<SkillScalarWhereInput[] | SkillScalarWhereInput>;
  updateMany?: Maybe<
    SkillUpdateManyWithWhereNestedInput[] | SkillUpdateManyWithWhereNestedInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  password: String;
  profilePic?: String;
  bannerPic?: String;
  location?: String;
  locationLat?: Float;
  locationLon?: Float;
  jobTitle?: String;
  profession?: String;
  industry?: String;
  website?: String;
  bio?: String;
  interests: String[];
  intro?: String;
  projects: String[];
  rank: Int;
  roles: Role[];
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profilePic: () => Promise<String>;
  bannerPic: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  profession: () => Promise<String>;
  industry: () => Promise<String>;
  website: () => Promise<String>;
  bio: () => Promise<String>;
  interests: () => Promise<String[]>;
  intro: () => Promise<String>;
  projects: () => Promise<String[]>;
  rank: () => Promise<Int>;
  roles: () => Promise<Role[]>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profilePic: () => Promise<AsyncIterator<String>>;
  bannerPic: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  locationLat: () => Promise<AsyncIterator<Float>>;
  locationLon: () => Promise<AsyncIterator<Float>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  industry: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  interests: () => Promise<AsyncIterator<String[]>>;
  intro: () => Promise<AsyncIterator<String>>;
  projects: () => Promise<AsyncIterator<String[]>>;
  rank: () => Promise<AsyncIterator<Int>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
}

export interface CommentLike {
  id: ID_Output;
}

export interface CommentLikePromise extends Promise<CommentLike>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = CommentPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface CommentLikeSubscription
  extends Promise<AsyncIterator<CommentLike>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = CommentSubscription>() => T;
  owner: <T = UserSubscription>() => T;
}

export interface CommentLikeNullablePromise
  extends Promise<CommentLike | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = CommentPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface Skill {
  id: ID_Output;
  skill: String;
  isExpert: Boolean;
}

export interface SkillPromise extends Promise<Skill>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  skill: () => Promise<String>;
  isExpert: () => Promise<Boolean>;
}

export interface SkillSubscription
  extends Promise<AsyncIterator<Skill>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  skill: () => Promise<AsyncIterator<String>>;
  isExpert: () => Promise<AsyncIterator<Boolean>>;
}

export interface SkillNullablePromise
  extends Promise<Skill | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  skill: () => Promise<String>;
  isExpert: () => Promise<Boolean>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface SkillSubscriptionPayload {
  mutation: MutationType;
  node: Skill;
  updatedFields: String[];
  previousValues: SkillPreviousValues;
}

export interface SkillSubscriptionPayloadPromise
  extends Promise<SkillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkillPreviousValuesPromise>() => T;
}

export interface SkillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkillPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkillEdge {
  node: Skill;
  cursor: String;
}

export interface SkillEdgePromise extends Promise<SkillEdge>, Fragmentable {
  node: <T = SkillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkillEdgeSubscription
  extends Promise<AsyncIterator<SkillEdge>>,
    Fragmentable {
  node: <T = SkillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregatePostLike {
  count: Int;
}

export interface AggregatePostLikePromise
  extends Promise<AggregatePostLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostLikeSubscription
  extends Promise<AsyncIterator<AggregatePostLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Filter {
  id: ID_Output;
}

export interface FilterPromise extends Promise<Filter>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
}

export interface FilterSubscription
  extends Promise<AsyncIterator<Filter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
}

export interface FilterNullablePromise
  extends Promise<Filter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
}

export interface PostLikeConnection {
  pageInfo: PageInfo;
  edges: PostLikeEdge[];
}

export interface PostLikeConnectionPromise
  extends Promise<PostLikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostLikeEdge>>() => T;
  aggregate: <T = AggregatePostLikePromise>() => T;
}

export interface PostLikeConnectionSubscription
  extends Promise<AsyncIterator<PostLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostLikeSubscription>() => T;
}

export interface Comment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  isUpdate: Boolean;
  content?: String;
  image?: String;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  isUpdate: () => Promise<Boolean>;
  owner: <T = UserPromise>() => T;
  parentPost: <T = PostPromise>() => T;
  parentComment: <T = CommentPromise>() => T;
  content: () => Promise<String>;
  image: () => Promise<String>;
  likes: <T = FragmentableArray<CommentLike>>(args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isUpdate: () => Promise<AsyncIterator<Boolean>>;
  owner: <T = UserSubscription>() => T;
  parentPost: <T = PostSubscription>() => T;
  parentComment: <T = CommentSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  likes: <T = Promise<AsyncIterator<CommentLikeSubscription>>>(args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  isUpdate: () => Promise<Boolean>;
  owner: <T = UserPromise>() => T;
  parentPost: <T = PostPromise>() => T;
  parentComment: <T = CommentPromise>() => T;
  content: () => Promise<String>;
  image: () => Promise<String>;
  likes: <T = FragmentableArray<CommentLike>>(args?: {
    where?: CommentLikeWhereInput;
    orderBy?: CommentLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface AggregateMeeting {
  count: Int;
}

export interface AggregateMeetingPromise
  extends Promise<AggregateMeeting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMeetingSubscription
  extends Promise<AsyncIterator<AggregateMeeting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  isUpdate: Boolean;
  content?: String;
  image?: String;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  isUpdate: () => Promise<Boolean>;
  content: () => Promise<String>;
  image: () => Promise<String>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isUpdate: () => Promise<AsyncIterator<Boolean>>;
  content: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface MeetingConnection {
  pageInfo: PageInfo;
  edges: MeetingEdge[];
}

export interface MeetingConnectionPromise
  extends Promise<MeetingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MeetingEdge>>() => T;
  aggregate: <T = AggregateMeetingPromise>() => T;
}

export interface MeetingConnectionSubscription
  extends Promise<AsyncIterator<MeetingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MeetingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMeetingSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  email: String;
  password: String;
  profilePic?: String;
  bannerPic?: String;
  location?: String;
  locationLat?: Float;
  locationLon?: Float;
  jobTitle?: String;
  profession?: String;
  industry?: String;
  website?: String;
  bio?: String;
  interests: String[];
  intro?: String;
  projects: String[];
  rank: Int;
  roles: Role[];
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profilePic: () => Promise<String>;
  bannerPic: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  profession: () => Promise<String>;
  industry: () => Promise<String>;
  website: () => Promise<String>;
  bio: () => Promise<String>;
  skills: <T = FragmentableArray<Skill>>(args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interests: () => Promise<String[]>;
  experience: <T = FragmentableArray<Experience>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  education: <T = FragmentableArray<Education>>(args?: {
    where?: EducationWhereInput;
    orderBy?: EducationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  connections: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  intro: () => Promise<String>;
  projects: () => Promise<String[]>;
  meetings: <T = FragmentableArray<Meeting>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedFilters: <T = FragmentableArray<Filter>>(args?: {
    where?: FilterWhereInput;
    orderBy?: FilterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rank: () => Promise<Int>;
  roles: () => Promise<Role[]>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profilePic: () => Promise<AsyncIterator<String>>;
  bannerPic: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  locationLat: () => Promise<AsyncIterator<Float>>;
  locationLon: () => Promise<AsyncIterator<Float>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  profession: () => Promise<AsyncIterator<String>>;
  industry: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  skills: <T = Promise<AsyncIterator<SkillSubscription>>>(args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interests: () => Promise<AsyncIterator<String[]>>;
  experience: <T = Promise<AsyncIterator<ExperienceSubscription>>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  education: <T = Promise<AsyncIterator<EducationSubscription>>>(args?: {
    where?: EducationWhereInput;
    orderBy?: EducationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  connections: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  intro: () => Promise<AsyncIterator<String>>;
  projects: () => Promise<AsyncIterator<String[]>>;
  meetings: <T = Promise<AsyncIterator<MeetingSubscription>>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedFilters: <T = Promise<AsyncIterator<FilterSubscription>>>(args?: {
    where?: FilterWhereInput;
    orderBy?: FilterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rank: () => Promise<AsyncIterator<Int>>;
  roles: () => Promise<AsyncIterator<Role[]>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profilePic: () => Promise<String>;
  bannerPic: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  profession: () => Promise<String>;
  industry: () => Promise<String>;
  website: () => Promise<String>;
  bio: () => Promise<String>;
  skills: <T = FragmentableArray<Skill>>(args?: {
    where?: SkillWhereInput;
    orderBy?: SkillOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  interests: () => Promise<String[]>;
  experience: <T = FragmentableArray<Experience>>(args?: {
    where?: ExperienceWhereInput;
    orderBy?: ExperienceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  education: <T = FragmentableArray<Education>>(args?: {
    where?: EducationWhereInput;
    orderBy?: EducationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  connections: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  intro: () => Promise<String>;
  projects: () => Promise<String[]>;
  meetings: <T = FragmentableArray<Meeting>>(args?: {
    where?: MeetingWhereInput;
    orderBy?: MeetingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savedFilters: <T = FragmentableArray<Filter>>(args?: {
    where?: FilterWhereInput;
    orderBy?: FilterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rank: () => Promise<Int>;
  roles: () => Promise<Role[]>;
}

export interface FilterEdge {
  node: Filter;
  cursor: String;
}

export interface FilterEdgePromise extends Promise<FilterEdge>, Fragmentable {
  node: <T = FilterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FilterEdgeSubscription
  extends Promise<AsyncIterator<FilterEdge>>,
    Fragmentable {
  node: <T = FilterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentLikeSubscriptionPayload {
  mutation: MutationType;
  node: CommentLike;
  updatedFields: String[];
  previousValues: CommentLikePreviousValues;
}

export interface CommentLikeSubscriptionPayloadPromise
  extends Promise<CommentLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentLikePreviousValuesPromise>() => T;
}

export interface CommentLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentLikePreviousValuesSubscription>() => T;
}

export interface AggregateExperience {
  count: Int;
}

export interface AggregateExperiencePromise
  extends Promise<AggregateExperience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentLikePreviousValues {
  id: ID_Output;
}

export interface CommentLikePreviousValuesPromise
  extends Promise<CommentLikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CommentLikePreviousValuesSubscription
  extends Promise<AsyncIterator<CommentLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ExperienceConnection {
  pageInfo: PageInfo;
  edges: ExperienceEdge[];
}

export interface ExperienceConnectionPromise
  extends Promise<ExperienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceEdge>>() => T;
  aggregate: <T = AggregateExperiencePromise>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface Meeting {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  place?: String;
}

export interface MeetingPromise extends Promise<Meeting>, Fragmentable {
  id: () => Promise<ID_Output>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  place: () => Promise<String>;
}

export interface MeetingSubscription
  extends Promise<AsyncIterator<Meeting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  place: () => Promise<AsyncIterator<String>>;
}

export interface MeetingNullablePromise
  extends Promise<Meeting | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  place: () => Promise<String>;
}

export interface EducationEdge {
  node: Education;
  cursor: String;
}

export interface EducationEdgePromise
  extends Promise<EducationEdge>,
    Fragmentable {
  node: <T = EducationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EducationEdgeSubscription
  extends Promise<AsyncIterator<EducationEdge>>,
    Fragmentable {
  node: <T = EducationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EducationSubscriptionPayload {
  mutation: MutationType;
  node: Education;
  updatedFields: String[];
  previousValues: EducationPreviousValues;
}

export interface EducationSubscriptionPayloadPromise
  extends Promise<EducationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EducationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EducationPreviousValuesPromise>() => T;
}

export interface EducationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EducationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EducationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EducationPreviousValuesSubscription>() => T;
}

export interface AggregateCommentLike {
  count: Int;
}

export interface AggregateCommentLikePromise
  extends Promise<AggregateCommentLike>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentLikeSubscription
  extends Promise<AsyncIterator<AggregateCommentLike>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EducationPreviousValues {
  id: ID_Output;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: String;
  endDateYear?: Int;
  location?: String;
  currentRole?: Boolean;
}

export interface EducationPreviousValuesPromise
  extends Promise<EducationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface EducationPreviousValuesSubscription
  extends Promise<AsyncIterator<EducationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  subText: () => Promise<AsyncIterator<String>>;
  startDateMonth: () => Promise<AsyncIterator<String>>;
  startDateYear: () => Promise<AsyncIterator<Int>>;
  endDateMonth: () => Promise<AsyncIterator<String>>;
  endDateYear: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<String>>;
  currentRole: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentLikeConnection {
  pageInfo: PageInfo;
  edges: CommentLikeEdge[];
}

export interface CommentLikeConnectionPromise
  extends Promise<CommentLikeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentLikeEdge>>() => T;
  aggregate: <T = AggregateCommentLikePromise>() => T;
}

export interface CommentLikeConnectionSubscription
  extends Promise<AsyncIterator<CommentLikeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentLikeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentLikeSubscription>() => T;
}

export interface Experience {
  id: ID_Output;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: String;
  endDateYear?: Int;
  location?: String;
  currentRole?: Boolean;
}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  subText: () => Promise<AsyncIterator<String>>;
  startDateMonth: () => Promise<AsyncIterator<String>>;
  startDateYear: () => Promise<AsyncIterator<Int>>;
  endDateMonth: () => Promise<AsyncIterator<String>>;
  endDateYear: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<String>>;
  currentRole: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExperienceNullablePromise
  extends Promise<Experience | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceSubscriptionPayload {
  mutation: MutationType;
  node: Experience;
  updatedFields: String[];
  previousValues: ExperiencePreviousValues;
}

export interface ExperienceSubscriptionPayloadPromise
  extends Promise<ExperienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValuesPromise>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperiencePreviousValues {
  id: ID_Output;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: String;
  endDateYear?: Int;
  location?: String;
  currentRole?: Boolean;
}

export interface ExperiencePreviousValuesPromise
  extends Promise<ExperiencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  subText: () => Promise<AsyncIterator<String>>;
  startDateMonth: () => Promise<AsyncIterator<String>>;
  startDateYear: () => Promise<AsyncIterator<Int>>;
  endDateMonth: () => Promise<AsyncIterator<String>>;
  endDateYear: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<String>>;
  currentRole: () => Promise<AsyncIterator<Boolean>>;
}

export interface SkillConnection {
  pageInfo: PageInfo;
  edges: SkillEdge[];
}

export interface SkillConnectionPromise
  extends Promise<SkillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkillEdge>>() => T;
  aggregate: <T = AggregateSkillPromise>() => T;
}

export interface SkillConnectionSubscription
  extends Promise<AsyncIterator<SkillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkillEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkillSubscription>() => T;
}

export interface SkillPreviousValues {
  id: ID_Output;
  skill: String;
  isExpert: Boolean;
}

export interface SkillPreviousValuesPromise
  extends Promise<SkillPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  skill: () => Promise<String>;
  isExpert: () => Promise<Boolean>;
}

export interface SkillPreviousValuesSubscription
  extends Promise<AsyncIterator<SkillPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  skill: () => Promise<AsyncIterator<String>>;
  isExpert: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FilterSubscriptionPayload {
  mutation: MutationType;
  node: Filter;
  updatedFields: String[];
  previousValues: FilterPreviousValues;
}

export interface FilterSubscriptionPayloadPromise
  extends Promise<FilterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilterPreviousValuesPromise>() => T;
}

export interface FilterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FilterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FilterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilterPreviousValuesSubscription>() => T;
}

export interface MeetingEdge {
  node: Meeting;
  cursor: String;
}

export interface MeetingEdgePromise extends Promise<MeetingEdge>, Fragmentable {
  node: <T = MeetingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MeetingEdgeSubscription
  extends Promise<AsyncIterator<MeetingEdge>>,
    Fragmentable {
  node: <T = MeetingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FilterPreviousValues {
  id: ID_Output;
}

export interface FilterPreviousValuesPromise
  extends Promise<FilterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface FilterPreviousValuesSubscription
  extends Promise<AsyncIterator<FilterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FilterConnection {
  pageInfo: PageInfo;
  edges: FilterEdge[];
}

export interface FilterConnectionPromise
  extends Promise<FilterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FilterEdge>>() => T;
  aggregate: <T = AggregateFilterPromise>() => T;
}

export interface FilterConnectionSubscription
  extends Promise<AsyncIterator<FilterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FilterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFilterSubscription>() => T;
}

export interface PostLike {
  id: ID_Output;
}

export interface PostLikePromise extends Promise<PostLike>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = PostPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface PostLikeSubscription
  extends Promise<AsyncIterator<PostLike>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = PostSubscription>() => T;
  owner: <T = UserSubscription>() => T;
}

export interface PostLikeNullablePromise
  extends Promise<PostLike | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = PostPromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface AggregateEducation {
  count: Int;
}

export interface AggregateEducationPromise
  extends Promise<AggregateEducation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEducationSubscription
  extends Promise<AsyncIterator<AggregateEducation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MeetingSubscriptionPayload {
  mutation: MutationType;
  node: Meeting;
  updatedFields: String[];
  previousValues: MeetingPreviousValues;
}

export interface MeetingSubscriptionPayloadPromise
  extends Promise<MeetingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MeetingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MeetingPreviousValuesPromise>() => T;
}

export interface MeetingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MeetingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MeetingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MeetingPreviousValuesSubscription>() => T;
}

export interface CommentLikeEdge {
  node: CommentLike;
  cursor: String;
}

export interface CommentLikeEdgePromise
  extends Promise<CommentLikeEdge>,
    Fragmentable {
  node: <T = CommentLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentLikeEdgeSubscription
  extends Promise<AsyncIterator<CommentLikeEdge>>,
    Fragmentable {
  node: <T = CommentLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MeetingPreviousValues {
  id: ID_Output;
  startTime: DateTimeOutput;
  endTime: DateTimeOutput;
  place?: String;
}

export interface MeetingPreviousValuesPromise
  extends Promise<MeetingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  place: () => Promise<String>;
}

export interface MeetingPreviousValuesSubscription
  extends Promise<AsyncIterator<MeetingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  place: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  lastUpdated: DateTimeOutput;
  isGoal: Boolean;
  goal?: String;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags: String[];
  images: String[];
  video?: String;
  pitch?: String;
  isPrivate: Boolean;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  lastUpdated: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  isGoal: () => Promise<Boolean>;
  goal: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  content: () => Promise<String>;
  tags: () => Promise<String[]>;
  images: () => Promise<String[]>;
  video: () => Promise<String>;
  pitch: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  likes: <T = FragmentableArray<PostLike>>(args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  owner: <T = UserSubscription>() => T;
  isGoal: () => Promise<AsyncIterator<Boolean>>;
  goal: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  locationLat: () => Promise<AsyncIterator<Float>>;
  locationLon: () => Promise<AsyncIterator<Float>>;
  content: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  images: () => Promise<AsyncIterator<String[]>>;
  video: () => Promise<AsyncIterator<String>>;
  pitch: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  likes: <T = Promise<AsyncIterator<PostLikeSubscription>>>(args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  lastUpdated: () => Promise<DateTimeOutput>;
  owner: <T = UserPromise>() => T;
  isGoal: () => Promise<Boolean>;
  goal: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  content: () => Promise<String>;
  tags: () => Promise<String[]>;
  images: () => Promise<String[]>;
  video: () => Promise<String>;
  pitch: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  likes: <T = FragmentableArray<PostLike>>(args?: {
    where?: PostLikeWhereInput;
    orderBy?: PostLikeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PostLikeEdge {
  node: PostLike;
  cursor: String;
}

export interface PostLikeEdgePromise
  extends Promise<PostLikeEdge>,
    Fragmentable {
  node: <T = PostLikePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostLikeEdgeSubscription
  extends Promise<AsyncIterator<PostLikeEdge>>,
    Fragmentable {
  node: <T = PostLikeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface AggregateFilter {
  count: Int;
}

export interface AggregateFilterPromise
  extends Promise<AggregateFilter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFilterSubscription
  extends Promise<AsyncIterator<AggregateFilter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostLikePreviousValues {
  id: ID_Output;
}

export interface PostLikePreviousValuesPromise
  extends Promise<PostLikePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PostLikePreviousValuesSubscription
  extends Promise<AsyncIterator<PostLikePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PostLikeSubscriptionPayload {
  mutation: MutationType;
  node: PostLike;
  updatedFields: String[];
  previousValues: PostLikePreviousValues;
}

export interface PostLikeSubscriptionPayloadPromise
  extends Promise<PostLikeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostLikePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostLikePreviousValuesPromise>() => T;
}

export interface PostLikeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostLikeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostLikeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostLikePreviousValuesSubscription>() => T;
}

export interface Education {
  id: ID_Output;
  name: String;
  subText: String;
  startDateMonth: String;
  startDateYear: Int;
  endDateMonth?: String;
  endDateYear?: Int;
  location?: String;
  currentRole?: Boolean;
}

export interface EducationPromise extends Promise<Education>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface EducationSubscription
  extends Promise<AsyncIterator<Education>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  subText: () => Promise<AsyncIterator<String>>;
  startDateMonth: () => Promise<AsyncIterator<String>>;
  startDateYear: () => Promise<AsyncIterator<Int>>;
  endDateMonth: () => Promise<AsyncIterator<String>>;
  endDateYear: () => Promise<AsyncIterator<Int>>;
  location: () => Promise<AsyncIterator<String>>;
  currentRole: () => Promise<AsyncIterator<Boolean>>;
}

export interface EducationNullablePromise
  extends Promise<Education | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = UserPromise>() => T;
  name: () => Promise<String>;
  subText: () => Promise<String>;
  startDateMonth: () => Promise<String>;
  startDateYear: () => Promise<Int>;
  endDateMonth: () => Promise<String>;
  endDateYear: () => Promise<Int>;
  location: () => Promise<String>;
  currentRole: () => Promise<Boolean>;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  lastUpdated: DateTimeOutput;
  isGoal: Boolean;
  goal?: String;
  location: String;
  locationLat: Float;
  locationLon: Float;
  content: String;
  tags: String[];
  images: String[];
  video?: String;
  pitch?: String;
  isPrivate: Boolean;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  lastUpdated: () => Promise<DateTimeOutput>;
  isGoal: () => Promise<Boolean>;
  goal: () => Promise<String>;
  location: () => Promise<String>;
  locationLat: () => Promise<Float>;
  locationLon: () => Promise<Float>;
  content: () => Promise<String>;
  tags: () => Promise<String[]>;
  images: () => Promise<String[]>;
  video: () => Promise<String>;
  pitch: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  isGoal: () => Promise<AsyncIterator<Boolean>>;
  goal: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  locationLat: () => Promise<AsyncIterator<Float>>;
  locationLon: () => Promise<AsyncIterator<Float>>;
  content: () => Promise<AsyncIterator<String>>;
  tags: () => Promise<AsyncIterator<String[]>>;
  images: () => Promise<AsyncIterator<String[]>>;
  video: () => Promise<AsyncIterator<String>>;
  pitch: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExperienceEdge {
  node: Experience;
  cursor: String;
}

export interface ExperienceEdgePromise
  extends Promise<ExperienceEdge>,
    Fragmentable {
  node: <T = ExperiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdge>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface AggregateSkill {
  count: Int;
}

export interface AggregateSkillPromise
  extends Promise<AggregateSkill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkillSubscription
  extends Promise<AsyncIterator<AggregateSkill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EducationConnection {
  pageInfo: PageInfo;
  edges: EducationEdge[];
}

export interface EducationConnectionPromise
  extends Promise<EducationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EducationEdge>>() => T;
  aggregate: <T = AggregateEducationPromise>() => T;
}

export interface EducationConnectionSubscription
  extends Promise<AsyncIterator<EducationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EducationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEducationSubscription>() => T;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Skill",
    embedded: false
  },
  {
    name: "Experience",
    embedded: false
  },
  {
    name: "Education",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "PostLike",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "CommentLike",
    embedded: false
  },
  {
    name: "Meeting",
    embedded: false
  },
  {
    name: "Filter",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
